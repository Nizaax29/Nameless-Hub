-- NMX HUB FINAL (with vertical slide + fade, ESP toggle includes pets + player Highlights)
-- Works as a Local GUI: injector-friendly or Studio LocalScript.
-- Place as a LocalScript in StarterPlayerScripts or paste into your exploit.

-- Services
local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer
if not player then return end
local PlayerGui = player:WaitForChild("PlayerGui", 5)
if not PlayerGui then return end

-- Helper style
local function applyNeon(inst, thickness)
    thickness = thickness or 2
    local c = Instance.new("UICorner", inst)
    c.CornerRadius = UDim.new(0, 8)
    local s = Instance.new("UIStroke", inst)
    s.Color = Color3.fromRGB(0, 200, 255)
    s.Thickness = thickness
end

-- Root
local screen = Instance.new("ScreenGui")
screen.Name = "NMXHub_Final"
screen.ResetOnSpawn = false
screen.Parent = PlayerGui

-- ===== NMX BUTTON (small + draggable) =====
local nmxBtn = Instance.new("TextButton", screen)
nmxBtn.Name = "NMXButton"
nmxBtn.Size = UDim2.new(0, 46, 0, 46)
nmxBtn.Position = UDim2.new(0.5, -23, 0.06, 0)
nmxBtn.BackgroundColor3 = Color3.fromRGB(12,12,12)
nmxBtn.AutoButtonColor = false
nmxBtn.Text = "NMX"
nmxBtn.Font = Enum.Font.GothamBold
nmxBtn.TextColor3 = Color3.fromRGB(0,220,255)
nmxBtn.TextScaled = true
applyNeon(nmxBtn, 2)

-- Dragging (robust, touch+mouse)
do
    local dragging, dragStart, startPos, dragInput
    nmxBtn.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            dragStart = input.Position
            startPos = nmxBtn.Position
            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then dragging = false end
            end)
        end
    end)
    nmxBtn.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
            dragInput = input
        end
    end)
    UserInputService.InputChanged:Connect(function(input)
        if dragInput == input and dragging then
            local delta = input.Position - dragStart
            nmxBtn.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
        end
    end)
end

-- ===== HUB FRAME (slide + fade) =====
local hub = Instance.new("Frame", screen)
hub.Name = "NMXHub"
hub.Size = UDim2.new(0, 540, 0, 400)
hub.Position = UDim2.new(0.5, -270, -1.3, 0) -- hidden above initially
hub.AnchorPoint = Vector2.new(0,0)
hub.BackgroundColor3 = Color3.fromRGB(18,18,18)
hub.BackgroundTransparency = 0.16
hub.BorderSizePixel = 0
applyNeon(hub, 3)
hub.Visible = false
local hubCorner = Instance.new("UICorner", hub)
hubCorner.CornerRadius = UDim.new(0, 12)

-- Title
local title = Instance.new("TextLabel", hub)
title.Size = UDim2.new(1,0,0,52)
title.Position = UDim2.new(0,0,0,0)
title.BackgroundTransparency = 1
title.Text = "NMX HUB"
title.TextColor3 = Color3.fromRGB(0,220,255)
title.Font = Enum.Font.GothamBold
title.TextScaled = true

-- Left: Tabs (scroll)
local tabScroll = Instance.new("ScrollingFrame", hub)
tabScroll.Size = UDim2.new(0, 150, 1, -80)
tabScroll.Position = UDim2.new(0, 10, 0, 68)
tabScroll.BackgroundTransparency = 1
tabScroll.BorderSizePixel = 0
tabScroll.AutomaticCanvasSize = Enum.AutomaticSize.Y
tabScroll.ScrollBarThickness = 6
local tabLayout = Instance.new("UIListLayout", tabScroll)
tabLayout.Padding = UDim.new(0,8)
tabLayout.SortOrder = Enum.SortOrder.LayoutOrder

-- Right: content viewport (clip) with stacked pages for vertical slide
local viewport = Instance.new("Frame", hub)
viewport.Size = UDim2.new(1, -180, 1, -80)
viewport.Position = UDim2.new(0, 170, 0, 68)
viewport.BackgroundTransparency = 1
viewport.ClipsDescendants = true

local pageMain = Instance.new("Frame", viewport)
pageMain.Size = UDim2.new(1,0,1,0)
pageMain.Position = UDim2.new(0,0,0,0)
pageMain.BackgroundTransparency = 1

local pageDiscord = Instance.new("Frame", viewport)
pageDiscord.Size = UDim2.new(1,0,1,0)
pageDiscord.Position = UDim2.new(0,0,1,0)
pageDiscord.BackgroundTransparency = 1

-- create tab helper
local function makeTab(name)
    local b = Instance.new("TextButton")
    b.Size = UDim2.new(1, -14, 0, 48)
    b.BackgroundColor3 = Color3.fromRGB(25,25,25)
    b.Text = name
    b.Font = Enum.Font.GothamBold
    b.TextSize = 14
    b.TextColor3 = Color3.fromRGB(0,220,255)
    b.AutoButtonColor = false
    applyNeon(b,1)
    b.Parent = tabScroll
    return b
end

local tabMain = makeTab("MAIN")
local tabDiscord = makeTab("DISCORD")

-- slide vertical between pages
local currentPage = "Main"
local slideDur = 0.28
local function slideTo(target)
    if target == currentPage then return end
    currentPage = target
    if target == "Discord" then
        TweenService:Create(pageMain, TweenInfo.new(slideDur, Enum.EasingStyle.Quad), {Position = UDim2.new(0,0,-1,0)}):Play()
        TweenService:Create(pageDiscord, TweenInfo.new(slideDur, Enum.EasingStyle.Quad), {Position = UDim2.new(0,0,0,0)}):Play()
    else
        TweenService:Create(pageMain, TweenInfo.new(slideDur, Enum.EasingStyle.Quad), {Position = UDim2.new(0,0,0,0)}):Play()
        TweenService:Create(pageDiscord, TweenInfo.new(slideDur, Enum.EasingStyle.Quad), {Position = UDim2.new(0,0,1,0)}):Play()
    end
end

tabMain.MouseButton1Click:Connect(function() slideTo("Main") end)
tabDiscord.MouseButton1Click:Connect(function() slideTo("Discord") end)

-- ensure both visible (positions control which is seen)
pageMain.Visible = true
pageDiscord.Visible = true
currentPage = "Main"

-- ===== Main page: scroll + buttons (vertical) =====
local mainScroll = Instance.new("ScrollingFrame", pageMain)
mainScroll.Size = UDim2.new(1,0,1,0)
mainScroll.Position = UDim2.new(0,0,0,0)
mainScroll.BackgroundTransparency = 1
mainScroll.BorderSizePixel = 0
mainScroll.AutomaticCanvasSize = Enum.AutomaticSize.Y
mainScroll.ScrollBarThickness = 6
local mainLayout = Instance.new("UIListLayout", mainScroll)
mainLayout.Padding = UDim.new(0,10)
mainLayout.SortOrder = Enum.SortOrder.LayoutOrder

local function makeMainBtn(text)
    local b = Instance.new("TextButton", mainScroll)
    b.Size = UDim2.new(1, -20, 0, 44)
    b.BackgroundColor3 = Color3.fromRGB(24,24,24)
    b.TextColor3 = Color3.fromRGB(0,220,255)
    b.Font = Enum.Font.GothamBold
    b.Text = text
    b.TextSize = 14
    b.AutoButtonColor = false
    applyNeon(b,1)
    local c = b:FindFirstChildOfClass("UICorner")
    if c then c.CornerRadius = UDim.new(0,6) end
    return b
end

-- Buttons
local walkBtn = makeMainBtn("Walk To Base")
local tweenBtn = makeMainBtn("Tween To Base")
local kickBtn = makeMainBtn("Auto Kick : OFF")
local espBtn = makeMainBtn("ESP : OFF")
local antiBtn = makeMainBtn("Anti Die : OFF")

-- ===== Discord page content =====
local discordLayout = Instance.new("UIListLayout", pageDiscord)
discordLayout.Padding = UDim.new(0,12)
discordLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
discordLayout.VerticalAlignment = Enum.VerticalAlignment.Top

local spacer = Instance.new("Frame", pageDiscord)
spacer.Size = UDim2.new(1,0,0,8)
spacer.BackgroundTransparency = 1

local copyBtn = Instance.new("TextButton", pageDiscord)
copyBtn.Size = UDim2.new(0, 380, 0, 44)
copyBtn.Position = UDim2.new(0.5, -190, 0, 20)
copyBtn.AnchorPoint = Vector2.new(0.5,0)
copyBtn.BackgroundColor3 = Color3.fromRGB(24,24,24)
copyBtn.TextColor3 = Color3.fromRGB(0,220,255)
copyBtn.Font = Enum.Font.GothamBold
copyBtn.Text = "Copy The Link"
copyBtn.TextSize = 14
copyBtn.AutoButtonColor = false
applyNeon(copyBtn,1)

copyBtn.MouseButton1Click:Connect(function()
    pcall(function() setclipboard("https://discord.gg/r7CCPpUTth") end)
    local prev = copyBtn.Text
    copyBtn.Text = "Copied !"
    task.delay(1.2, function() copyBtn.Text = prev end)
end)

-- ===== Open / Close hub (slide + fade) =====
do
    local opened = false
    local openPos = UDim2.new(0.5, -270, 0.5, -200)
    local closedPos = UDim2.new(0.5, -270, -1.3, 0)

    local function tweenOpen()
        hub.Visible = true
        hub.Position = closedPos
        -- slide in
        local t1 = TweenService:Create(hub, TweenInfo.new(0.36, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Position = openPos})
        -- fade in background slightly (to 0.12)
        local t2 = TweenService:Create(hub, TweenInfo.new(0.36, Enum.EasingStyle.Quad), {BackgroundTransparency = 0.12})
        t1:Play(); t2:Play()
    end

    local function tweenClose()
        local t1 = TweenService:Create(hub, TweenInfo.new(0.28, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {Position = closedPos})
        local t2 = TweenService:Create(hub, TweenInfo.new(0.28, Enum.EasingStyle.Quad), {BackgroundTransparency = 1})
        t1:Play(); t2:Play()
        task.delay(0.30, function() hub.Visible = false hub.BackgroundTransparency = 0.16 end)
    end

    nmxBtn.MouseButton1Click:Connect(function()
        opened = not opened
        if opened then tweenOpen() else tweenClose() end
    end)
end

-- ===== Walk / Tween To Base (safe local implementations) =====
local function findDeliveryHitbox()
    local plots = workspace:FindFirstChild("Plots")
    if not plots then return nil end
    for _, plot in pairs(plots:GetChildren()) do
        local sign = plot:FindFirstChild("PlotSign")
        if sign and sign:FindFirstChild("YourBase") and sign.YourBase.Enabled then
            local hitbox = plot:FindFirstChild("DeliveryHitbox")
            if hitbox and hitbox:IsA("BasePart") then return hitbox end
        end
    end
    return nil
end

walkBtn.MouseButton1Click:Connect(function()
    local char = player.Character
    if not char then return end
    local humanoid = char:FindFirstChild("Humanoid")
    if not humanoid then return end
    local target = findDeliveryHitbox()
    if target then
        humanoid:MoveTo(target.Position)
    else
        walkBtn.Text = "Base not found"
        task.delay(1.2, function() walkBtn.Text = "Walk To Base" end)
    end
end)

tweenBtn.MouseButton1Click:Connect(function()
    local char = player.Character
    if not char then return end
    local hrp = char:FindFirstChild("HumanoidRootPart")
    if not hrp then return end
    local target = findDeliveryHitbox()
    if not target then
        tweenBtn.Text = "Base not found"
        task.delay(1.2, function() tweenBtn.Text = "Tween To Base" end)
        return
    end
    local goalC = CFrame.new(target.Position + Vector3.new(0,8,0))
    local dist = (hrp.Position - goalC.Position).Magnitude
    local speed = 12 -- slower tween
    local duration = math.max(0.15, dist / speed)
    local tw = TweenService:Create(hrp, TweenInfo.new(duration, Enum.EasingStyle.Linear), {CFrame = goalC})
    tw:Play()
end)

-- ===== Auto Kick (client-side notify only) =====
local autoKick = false
kickBtn.MouseButton1Click:Connect(function()
    autoKick = not autoKick
    kickBtn.Text = autoKick and "Auto Kick : ON" or "Auto Kick : OFF"
end)
task.spawn(function()
    while true do
        task.wait(1)
        if autoKick then
            for _, g in pairs(player.PlayerGui:GetDescendants()) do
                if (g:IsA("TextLabel") or g:IsA("TextButton") or g:IsA("TextBox")) and type(g.Text) == "string" then
                    if string.find(string.lower(g.Text), "you stole") then
                        kickBtn.Text = "Detected: 'you stole'"
                        task.delay(1.6, function()
                            if autoKick then kickBtn.Text = "Auto Kick : ON" else kickBtn.Text = "Auto Kick : OFF" end
                        end)
                    end
                end
            end
        end
    end
end)

-- ===== Anti Die (visual + health restore in Studio only) =====
local antiOn = false
local function protectChar(char)
    if not char then return end
    local humanoid = char:FindFirstChild("Humanoid") or char:WaitForChild("Humanoid", 5)
    if not humanoid then return end
    local conn
    conn = humanoid.HealthChanged:Connect(function()
        if antiOn and humanoid and humanoid.Health < 1 then
            humanoid.Health = humanoid.MaxHealth
        end
    end)
    -- return connection so we can disconnect later if needed
    return conn
end
local antiConn
antiBtn.MouseButton1Click:Connect(function()
    antiOn = not antiOn
    antiBtn.Text = antiOn and "Anti Die : ON" or "Anti Die : OFF"
    if antiOn then
        if player.Character then antiConn = protectChar(player.Character) end
        player.CharacterAdded:Connect(function(c) task.wait(0.4) protectChar(c) end)
    else
        if antiConn and antiConn.Disconnect then pcall(function() antiConn:Disconnect() end) end
        -- optionally remove ForceField if you created one (not created here)
    end
end)

-- ====== ESP system (TOGGLE) ======
-- Integrates your pet-finding + billboard + beam code + player Highlights.
local espOn = false
local espLoop = false
local espTask -- thread handle

-- Containers
local function ensureContainers()
    if not player.PlayerGui:FindFirstChild("ESP") then
        local f = Instance.new("Folder")
        f.Name = "ESP"
        f.Parent = player.PlayerGui
    end
    if not workspace:FindFirstChild("ESP_Lines") then
        local lf = Instance.new("Folder")
        lf.Name = "ESP_Lines"
        lf.Parent = workspace
    end
end

-- Pet ESP variables
local ESP_FOLDER, LINE_FOLDER
local currentESP -- BillboardGui
local currentBeam
local currentPetInfo
local a0, a1

-- parseMoneyPerSec (from your script)
local function parseMoneyPerSec(text)
    if type(text) ~= "string" then return 0 end
    text = text:match("^%s*(.-)%s*$")
    local number, suffix = text:match("%$([%d%.]+)%s*([kKmMbB]?)%s*/?s?")
    number = tonumber(number) or 0
    if suffix then
        suffix = suffix:lower()
        if suffix == "k" then number = number * 1000
        elseif suffix == "m" then number = number * 1_000_000
        elseif suffix == "b" then number = number * 1_000_000_000 end
    end
    return number
end

local function createESPbillboard(petName, infoText, mutationText, targetPart)
    if currentESP then pcall(function() currentESP:Destroy() end) end
    local billboard = Instance.new("BillboardGui")
    billboard.Size = UDim2.new(0,150,0,50)
    billboard.AlwaysOnTop = true
    billboard.Adornee = targetPart
    billboard.Parent = ESP_FOLDER
    billboard.StudsOffset = Vector3.new(0,3,0)
    local textLabel = Instance.new("TextLabel", billboard)
    textLabel.Size = UDim2.new(1,0,1,0)
    textLabel.BackgroundTransparency = 1
    textLabel.TextColor3 = Color3.fromRGB(255,255,255)
    textLabel.TextStrokeColor3 = Color3.fromRGB(0,0,0)
    textLabel.TextStrokeTransparency = 0
    textLabel.TextScaled = false
    textLabel.TextSize = 10
    textLabel.RichText = true
    textLabel.Text = string.format(
        '<font color="rgb(255,0,0)">%s</font>\n<font color="rgb(0,255,0)">%s</font>\n<font color="rgb(255,255,0)">%s</font>',
        petName, infoText, mutationText or ""
    )
    currentESP = billboard
end

local function createBeamToPart(targetPart)
    if not targetPart then return end
    local char = player.Character
    if not char or not char:FindFirstChild("HumanoidRootPart") then return end
    if currentBeam then
        pcall(function() currentBeam:Destroy() end)
        if a0 then pcall(function() a0:Destroy() end) end
        if a1 then pcall(function() a1:Destroy() end) end
    end
    a0 = Instance.new("Attachment")
    a0.Parent = char.HumanoidRootPart
    a1 = Instance.new("Attachment")
    a1.Parent = targetPart
    local beam = Instance.new("Beam")
    beam.Attachment0 = a0
    beam.Attachment1 = a1
    beam.Width0 = 0.35
    beam.Width1 = 0.35
    beam.FaceCamera = true
    beam.LightInfluence = 0
    beam.Parent = LINE_FOLDER
    currentBeam = beam
    task.spawn(function()
        while currentBeam and currentBeam.Parent do
            local color = Color3.fromHSV((tick() % 5) / 5, 1, 1)
            pcall(function() currentBeam.Color = ColorSequence.new(color) end)
            task.wait(0.06)
        end
    end)
end

-- findBestPet (from your script)
local function findBestPet()
    local PlotsFolder = workspace:FindFirstChild("Plots")
    if not PlotsFolder then return nil end
    local bestValue = -1
    local bestPet = nil
    for _, plot in ipairs(PlotsFolder:GetChildren()) do
        local podiums = plot:FindFirstChild("AnimalPodiums")
        if podiums then
            for _, podium in ipairs(podiums:GetChildren()) do
                local spawnPart = podium:FindFirstChild("Base") and podium.Base:FindFirstChild("Spawn")
                if spawnPart then
                    local attachment = spawnPart:FindFirstChild("Attachment")
                    local overhead = attachment and attachment:FindFirstChild("AnimalOverhead")
                    if overhead then
                        local nameLabel = overhead:FindFirstChild("DisplayName")
                        local genLabel = overhead:FindFirstChild("Generation")
                        local mutationLabel = overhead:FindFirstChild("Mutation")
                        if genLabel then
                            local petName = nameLabel and nameLabel.Text or "Unknown"
                            local genText = genLabel.Text
                            local mutationText = mutationLabel and mutationLabel.Text or ""
                            local mps = parseMoneyPerSec(genText)
                            local genNumber = tonumber(genText:match("%d+")) or 0
                            local value = mps > 0 and mps or genNumber
                            if value > bestValue then
                                bestValue = value
                                bestPet = {name = petName, info = genText, mutation = mutationText, part = spawnPart, value = value}
                            end
                        end
                    end
                end
            end
        end
    end
    return bestPet
end

local function updatePetESP()
    local pet = findBestPet()
    if pet then
        local needUpdate = false
        if not currentESP then needUpdate = true
        elseif currentPetInfo then
            if pet.value > currentPetInfo.value or pet.mutation ~= currentPetInfo.mutation then needUpdate = true end
        end
        if needUpdate then
            currentPetInfo = pet
            createESPbillboard(pet.name, pet.info, pet.mutation, pet.part)
            createBeamToPart(pet.part)
        end
    else
        if currentESP then pcall(function() currentESP:Destroy() end); currentESP = nil; currentPetInfo = nil end
        if currentBeam then pcall(function() currentBeam:Destroy() end); currentBeam = nil end
    end
end

-- Player Highlights
local playerHighlights = {} -- map player -> Highlight instance
local function addPlayerHighlight(plr)
    if not plr or plr == player then return end
    if playerHighlights[plr] then return end
    local char = plr.Character
    if not char then return end
    local hl = Instance.new("Highlight")
    hl.FillColor = Color3.fromRGB(0,200,255)
    hl.OutlineColor = Color3.fromRGB(0,150,200)
    hl.FillTransparency = 0.6
    hl.Parent = char
    playerHighlights[plr] = hl
end
local function removePlayerHighlight(plr)
    if playerHighlights[plr] then
        pcall(function() playerHighlights[plr]:Destroy() end)
        playerHighlights[plr] = nil
    end
end
local function clearAllPlayerHighlights()
    for p, h in pairs(playerHighlights) do
        pcall(function() h:Destroy() end)
    end
    playerHighlights = {}
end

-- Enable/disable: will highlight all players (except local) and keep updated on join/respawn
local playerConns = {}
local function enablePlayerHighlights()
    for _, pl
